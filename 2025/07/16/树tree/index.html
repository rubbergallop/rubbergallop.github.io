<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>树(tree) | Welcome</title><meta name="author" content="galloprubber"><meta name="copyright" content="galloprubber"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树的基本概念1.树的定义树是由n个结点（n≥0）组成的有限集，当n&#x3D;0是称为空树。在任一棵非空树中应满足： ​	1.有且仅有一个根结点 ​	2.当n≥1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并	   且称为根的子树 树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点： ​	1.树的根结点没有前驱，除根结点以外的所有">
<meta property="og:type" content="article">
<meta property="og:title" content="树(tree)">
<meta property="og:url" content="http://example.com/2025/07/16/%E6%A0%91tree/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="树的基本概念1.树的定义树是由n个结点（n≥0）组成的有限集，当n&#x3D;0是称为空树。在任一棵非空树中应满足： ​	1.有且仅有一个根结点 ​	2.当n≥1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并	   且称为根的子树 树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点： ​	1.树的根结点没有前驱，除根结点以外的所有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-16T02:50:00.000Z">
<meta property="article:modified_time" content="2025-09-28T08:24:45.834Z">
<meta property="article:author" content="galloprubber">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "树(tree)",
  "url": "http://example.com/2025/07/16/%E6%A0%91tree/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-07-16T02:50:00.000Z",
  "dateModified": "2025-09-28T08:24:45.834Z",
  "author": [
    {
      "@type": "Person",
      "name": "galloprubber",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/16/%E6%A0%91tree/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '树(tree)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-Heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Welcome</span></a><a class="nav-page-title" href="/"><span class="site-name">树(tree)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-Heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">树(tree)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-16T02:50:00.000Z" title="发表于 2025-07-16 10:50:00">2025-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-28T08:24:45.834Z" title="更新于 2025-09-28 16:24:45">2025-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><h2 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1.树的定义"></a>1.树的定义</h2><p>树是由n个结点（n≥0）组成的有限集，当n&#x3D;0是称为空树。在任一棵非空树中应满足：</p>
<p>​	1.有且仅有一个根结点</p>
<p>​	2.当n≥1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并	   且称为根的子树</p>
<p>树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p>
<p>​	1.树的根结点没有前驱，除根结点以外的所有结点都有且只有一个前驱</p>
<p>​	2.树的所有结点可以有零个或多个后继</p>
<p>所以n个结点的树有n-1条边</p>
<h2 id="2-树的概念"><a href="#2-树的概念" class="headerlink" title="2.树的概念"></a>2.树的概念</h2><p><img src="/../image/tree/1.png" alt="1"></p>
<p>对于结点J，根A到结点J的唯一路径上的任意结点,称为结点J的祖先，而结点K是他们的子孙</p>
<p>路径上最接近结点K的结点E称为K的双亲，而K为结点E的孩子。根A是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟,如结点K和结点J有相同的双亲E,即K和J为兄弟</p>
<p>树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。如结点B的度为2，结点D的度为1，树的度为3</p>
<p>度大于0的结点称为分支结点(又称非终端结点)；度为0(没有子女结点)的结点称为叶子结点(又称终端结点)。在分支结点中，每个结点的分支数就是该结点的度</p>
<p>结点的深度、高度和层次：<br>结点的层次从树根开始定义，根结点为第1层，它的子结点为第2层，以此类推。双亲在同一层的结点互为堂兄弟<br>结点的深度是从根结点开始自顶向下逐层累加的<br>结点的高度是从叶结点开始自底向上逐层累加的<br>树的高度(或深度)是树中结点的最大层数，图中树的高度为4</p>
<p>有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。假设图为有序树，若将子结点位置互换，则变成一棵不同的树</p>
<p>路径和路径长度：树中两个结点之间的路径是由这两个结点之间所经过的结点构成的，而路径长度是路径上所经过的边的个数</p>
<p>森林：森林是m （m≥0）棵互不相交的树的集合。只要把树的根结点删去就成了森林，反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，森林就变成了树</p>
<h2 id="3-树的基本性质"><a href="#3-树的基本性质" class="headerlink" title="3.树的基本性质"></a>3.树的基本性质</h2><p>1.树中的结点数等于所有结点的度数加1</p>
<p>2.度为m的树中第i层最多有m<sup>i-1</sup>个结点（i≥1)</p>
<p>3.高度为h的m叉树至多有（m<sup>h</sup>-1)&#x2F;(m-1)个结点</p>
<p>4.具有n个结点的m叉树的最小高度为[log<sub>m</sub>(n(m-1)+1)]</p>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><h2 id="1-双亲表示法（顺序存储）"><a href="#1-双亲表示法（顺序存储）" class="headerlink" title="1.双亲表示法（顺序存储）"></a>1.双亲表示法（顺序存储）</h2><p>即每个结点中保存一个指示器指向双亲的位置</p>
<p>以上面概念介绍中的树为例</p>
<p><img src="/../image/tree/2.png" alt="2"></p>
<p>图示：</p>
<table>
<thead>
<tr>
<th align="center">下标</th>
<th align="center">数组元素data</th>
<th align="center">双亲位置域parent</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">A</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">D</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">C</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">F</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">G</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">H</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">I</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">J</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">K</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">L</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TREE_SIZE 100			<span class="comment">//结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;      				<span class="comment">//数据元素</span></span><br><span class="line">	<span class="type">int</span> parent;							<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>						<span class="comment">//树的类型定义</span></span><br><span class="line">&#123;					</span><br><span class="line">	Node tree[TREE_SIZE];	  <span class="comment">//双亲表示</span></span><br><span class="line">	<span class="type">int</span> n;									<span class="comment">//结点数</span></span><br><span class="line">&#125;Tree;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1.根结点固定为下标0的位置，双亲位置为-1表示其无双亲结点</p>
<p>2.增加结点：写入增加元素的数据，并记录其双亲结点的位置</p>
<p>3.删除结点：</p>
<p>（1）将删除结点的双亲位置设为-1，然后结点数n减1</p>
<p>（2）将尾部数据移动到要删除结点的位置，然后结点数n减1</p>
<p>如果删除了一个子树的根结点，则需要将这棵子树的所有结点都删掉，即需要查询孩子结点</p>
<p>4.查询：该表示法对于寻找双亲比较方便，而查找孩子结点需要遍历整个树</p>
<h2 id="2-孩子表示法（顺序-链式存储）"><a href="#2-孩子表示法（顺序-链式存储）" class="headerlink" title="2.孩子表示法（顺序+链式存储）"></a>2.孩子表示法（顺序+链式存储）</h2><p>顺序存储各个结点，每个结点保存孩子链表的头指针</p>
<p>图示：</p>
<p><img src="/../image/tree/3.png" alt="3"></p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> TREE_SIZE 100			    <span class="comment">//结点数</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> child;								<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">CTNode</span>* next;			<span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">CTNode</span>* firstchild;		<span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	CTBox nodes[TREE_SIZE];</span><br><span class="line">	<span class="type">int</span> n, r;										<span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<p>如果要查找某个结点的孩子或兄弟比较方便，只需要查找这个结点孩子的单链表即可</p>
<p>而查找双亲结点需要遍历整棵树</p>
<h2 id="3-孩子兄弟表示法（链式存储）"><a href="#3-孩子兄弟表示法（链式存储）" class="headerlink" title="3.孩子兄弟表示法（链式存储）"></a>3.孩子兄弟表示法（链式存储）</h2><p>我们发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的，因此，可以设置两个指针，分别指向该结点的第一个孩子和它的右兄弟</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">CSNode</span>* firstchild, * nextsibling; <span class="comment">//分别代表左孩子和右兄弟</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/../image/tree/4.png" alt="4"></p>
<p>可以看出，这是一棵二叉树</p>
<p>将原树转化为二叉树后如下</p>
<p><img src="/../image/tree/5.png" alt="5"></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="一、二叉树的概念"><a href="#一、二叉树的概念" class="headerlink" title="一、二叉树的概念"></a>一、二叉树的概念</h2><h3 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="1.二叉树的定义"></a>1.二叉树的定义</h3><p>二叉树的特点是每个结点最多有两棵子树（即不存在度大于2的结点），并且二叉树的结点有左右之分，顺序不能颠倒</p>
<p>二叉树是n(n≥0)个结点的有限集合</p>
<p>​	1.空二叉树，n&#x3D;0</p>
<p>​	2.由一个根结点和两个互不相交的子树（根的左子树和右子树）组成，左子树和右子树分别是一棵二叉树</p>
<p>二叉树是有序树，即使某个结点只有一棵子树，也要区分是左子树还是右子树</p>
<p>特殊二叉树的定义：</p>
<p>（1）斜树：</p>
<p>​	所有结点都只有左子树的树被称为左斜树，所有结点都只有右子树的树被称为右斜树，二者统称为斜树</p>
<p>（2）满二叉树：<br>	高度为h，含有2<sup>h-1</sup>个结点的二叉树称为满二叉树，即每层都含有最多的结点，除最下层的叶子结点外，每个结点的度数均为2。编号特征：根结点编号为1，从上至下，从左至右，对于编号为i的结点，若有双亲，则双亲为<code>i/2</code>；若有左孩子，则左孩子为<code>2*i</code>； 若有右孩子，则左右孩子为<code>2*i+1</code></p>
<p><img src="/../image/tree/6.png" alt="6"></p>
<p>（3）完全二叉树：</p>
<p>​	高度为h，含有n个结点的二叉树，当且仅当其每个结点的编号都与高度为h的满二叉树中编号为1～n的点一一对应时，称为完全二叉树</p>
<p><img src="/../image/tree/7.png" alt="7"></p>
<p>特征：</p>
<p>1.若i≤n&#x2F;2,则结点i为分支结点，否则为叶子结点</p>
<p>2.叶子结点只可能在最大的两层上出现，对于最大层次中的叶子结点，都依次排列在该层最左边的位置上</p>
<p>3.若有度为1的结点，则只可能有一个，且该结点有左孩子而无右孩子</p>
<p>4.按层序编号后，一旦出现某结点为叶子结点或只有左孩子，则编号大于该结点的所有结点均为叶子结点</p>
<p>5.若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n&#x2F;2）只有左孩子，没有右孩子，其余分支结点左，右孩子都有</p>
<p>（4）二叉排序树</p>
<p>左子树上所有结点的关键字均小于根结点的关键字，右子上所有结点的关键子均大于根结点的关键字；左右子树均是一棵二叉排序树</p>
<p>（5）平衡二叉树</p>
<p>树上任一结点的左子树与右子树的深度之差不超过1</p>
<h3 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="2.二叉树的性质"></a>2.二叉树的性质</h3><p>1.任意一棵树，若结点数量为n，则边的数量为n-1</p>
<p>2.非空二叉树上的叶子结点数等于度为2的结点数加1</p>
<p>3.非空二叉树的第k层上最多有2<sup>k-1</sup>个结点(k≥1)</p>
<p>4.高度为h的二叉树最多有2<sup>h-1</sup>个结点(h≥1)</p>
<p>5.对完全二叉树从上到下，从左到右依次编号（1～n）后，有以下关系：</p>
<ul>
<li>当i&gt;1时，结点i的双亲编号为i&#x2F;2；当i为偶数时，它是双亲的左孩子，当i为奇数时，它是双亲的右孩子</li>
<li>当2i&lt;n时，结点i的左孩子编号为2i，否则无左孩子</li>
<li>当2i+1≤n时，结点i的右孩子编号为2i+1，否则无右孩子</li>
<li>结点i所在深度为（log<sub>2</sub>i）+1</li>
</ul>
<p>6.具有n个结点（n&gt;0）的完全二叉树的高度为（log<sub>2</sub>n）+1</p>
<h3 id="3-二叉树的存储结构"><a href="#3-二叉树的存储结构" class="headerlink" title="3.二叉树的存储结构"></a>3.二叉树的存储结构</h3><p>1.顺序存储结构</p>
<p>即使用一组连续的存储单元从上到下，从左到右存储二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在下标一维数组中下标为i-1的分量中</p>
<p>不难看出，此种方法比较适合满二叉树与完全二叉树，对于一般的二叉树，需要添加一些不存在的空结点，让每个结点与完全二叉树中的结点位置对应，因此此种方法对于一般的二叉树适用性不高</p>
<p>以下图为例，0代表不存在的空结点</p>
<p><img src="/../image/tree/8.png" alt="8"></p>
<p>2.链式存储结构</p>
<p>二叉树的每个结点最多有两个孩子，所以使用一个数据域和两个指针域来存储，称这样的链表叫做二叉链表</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>上图使用此种方法存储的图示如下：</p>
<img src="../image/tree/9.png" alt="9"  />

<p>在含有n个结点的二叉链表中，含有n+1个空链域</p>
<h2 id="二、遍历二叉树"><a href="#二、遍历二叉树" class="headerlink" title="二、遍历二叉树"></a>二、遍历二叉树</h2><p>遍历二叉树是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点都被访问且只被访问一次</p>
<h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>操作过程：</p>
<p>（1）访问根结点</p>
<p>（2）先序遍历左子树</p>
<p>（3）先序遍历右子树</p>
<p>图示：</p>
<img src="../image/tree/10.png" alt="10" style="zoom:67%;" />

<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">visit</span>(T);	<span class="comment">//访问根节点</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><p>操作过程：</p>
<p>（1）中序遍历左子树</p>
<p>（2）访问根结点</p>
<p>（3）中序遍历右子树</p>
<p>图示：</p>
<img src="../image/tree/11.png" alt="11" style="zoom:67%;" />

<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><p>操作过程：</p>
<p>（1）后序遍历左子树</p>
<p>（2）后序遍历右子树</p>
<p>（3）访问根结点</p>
<p>图示：</p>
<img src="../image/tree/12.png" alt="12" style="zoom:67%;" />

<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">		<span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4.层次遍历"></a>4.层次遍历</h3><p>即从上到下按照层次顺序遍历</p>
<p>图示：</p>
<img src="../image/tree/13.png" alt="13" style="zoom:67%;" />

<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);	<span class="comment">//初始化辅助队列</span></span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="built_in">EnQueue</span>(Q, T);	<span class="comment">//将根节点入队</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123;	<span class="comment">//队列不空则循环</span></span><br><span class="line">		<span class="built_in">DeQueue</span>(Q, p);	<span class="comment">//队头结点出队</span></span><br><span class="line">		<span class="built_in">visit</span>(p);	<span class="comment">//访问出队结点</span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;lchild);	<span class="comment">//左子树不空，则左子树根节点入队</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;rchild);	<span class="comment">//右子树不空，则右子树根节点入队</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、线索二叉树"><a href="#三、线索二叉树" class="headerlink" title="三、线索二叉树"></a>三、线索二叉树</h2><h3 id="1-线索二叉树的概念"><a href="#1-线索二叉树的概念" class="headerlink" title="1.线索二叉树的概念"></a>1.线索二叉树的概念</h3><p>遍历二叉树使得二叉树中的结点排列成了一个线性序列，不同的规则得到不同的遍历序列，从而该序列中除了第一个和最后一个结点外的每个结点都有一个直接前驱和直接后继</p>
<p>而传统的链式存储二叉树仅能体现一种父子关系，不能直接得到结点的前驱和后继</p>
<p><img src="/../image/tree/14.png" alt="14"></p>
<p>对于一个有n个结点的二叉链表，可以看出，每个结点有分别指向左右孩子的两个指针域，即共有2n个指针域，n个结点的二叉树共有n-1个条分支线数，所以存在n+1个空指针域</p>
<p>由此，可以利用这些空指针来存放其前驱和后继，从而可以像遍历单链表一样遍历二叉树</p>
<p><strong>把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)</strong></p>
<p>其结构如下图所示</p>
<p><img src="/../image/tree/15.png" alt="15"></p>
<ul>
<li>当ltag为0时指向该结点的左孩子，为1时指向该结点的前驱</li>
<li>当rtag为0时指向该结点的右孩子，为1时指向该结点的后继</li>
</ul>
<p>从而可以将上图的二叉链表修改为下图</p>
<p><img src="/../image/tree/16.png" alt="16"></p>
<h3 id="2-线索二叉树的结构实现"><a href="#2-线索二叉树的结构实现" class="headerlink" title="2.线索二叉树的结构实现"></a>2.线索二叉树的结构实现</h3><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">	<span class="type">char</span> data;	<span class="comment">//数据元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;	<span class="comment">//左、右孩子指针</span></span><br><span class="line">	<span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>

<h3 id="3-二叉树的线索化"><a href="#3-二叉树的线索化" class="headerlink" title="3.二叉树的线索化"></a>3.二叉树的线索化</h3><p>二叉树的线索化即将二叉链表中的空指针改为指向前驱或后继的线索，实际就是通过遍历一次二叉树，在遍历的过程中进行空指针的修改</p>
<p>（1）中序线索二叉树</p>
<p>设指针<code>pre</code>指向刚访问过的点，<code>p</code>指向现在访问的点，即<code>pre</code>指向<code>p</code>的前驱。在遍历的过程中，检查<code>p</code>的左指针是否为空，若为空就将它指向<code>pre</code>，检查<code>pre</code>的右指针是否为空，若为空就将它指向<code>p</code></p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree p, ThreadTree pre)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InThread</span>(p-&gt;lchild, pre);	<span class="comment">//递归，线索化左子树</span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">			p-&gt;lchild = pre;</span><br><span class="line">			p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;rchild = p;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;	<span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">		<span class="built_in">InThread</span>(p-&gt;rchild, pre);	<span class="comment">//递归，线索化右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过中序遍历建立中序线索二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InThread</span>(T, pre);	<span class="comment">//线索化二叉树</span></span><br><span class="line">		pre-&gt;rchild = <span class="literal">NULL</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><h2 id="一、二叉排序树"><a href="#一、二叉排序树" class="headerlink" title="一、二叉排序树"></a>一、二叉排序树</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>二叉排序树（二叉查找树）或者是一棵空树，或者是一棵具有以下性质的二叉树：</p>
<ul>
<li>若左子树非空，则左子树上的所有结点的值均小于根结点的值</li>
<li>若右子树非空，则右子树上的所有结点的值均大于根结点的值</li>
<li>左、右子树也分别是一棵二叉排序树</li>
</ul>
<p>根据此定义，对二叉排序树进行中序遍历后，可以得到一个递增的有序序列</p>
<h3 id="2-二叉排序树的基本操作"><a href="#2-二叉排序树的基本操作" class="headerlink" title="2.二叉排序树的基本操作"></a>2.二叉排序树的基本操作</h3><p>构造一棵二叉树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>(1)查找操作</p>
<p>递归查找二叉排序树<code>T</code>中是否存在<code>key</code>，其中指针<code>f</code>指向<code>T</code>的双亲，其初始调用值为<code>NULL</code> ，若查找成功，则指针<code>p</code>指向该数据元素结点，并返回<code>true</code> ，否则指针<code>p</code>指向查找路径上访问的最后一个结点并返回<code>false</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!T)</span><br><span class="line">	&#123;</span><br><span class="line">		*p = f;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//查找成功</span></span><br><span class="line">		*p = T;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key, T, p);	<span class="comment">//在左子树继续查找</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key, T, p);	<span class="comment">//在右子树继续查找</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）插入操作</p>
<p>先在二叉树<code>T</code>中查找<code>key</code>，若不存在，则插入<code>key</code>并返回<code>true</code>，否则返回<code>false</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p, s;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(*T, key, <span class="literal">NULL</span>, &amp;p))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//查找不成功</span></span><br><span class="line">		s = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">		s-&gt;data = key;</span><br><span class="line">		s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span>(!p)</span><br><span class="line">		&#123;</span><br><span class="line">			*T = s;	<span class="comment">//插入s为新的根节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;lchild = s;	<span class="comment">//插入s为左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;rchild = s;	<span class="comment">//插入s为右孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;			</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//已有关键字相同的结点，不再插入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）删除操作</p>
<p>删除操作比查找和插入操作复杂，要删除的结点分为三种情况：</p>
<ul>
<li>叶子结点</li>
<li>仅有左或右子树的结点</li>
<li>左右子树都有的结点</li>
</ul>
<p>对于第一种情况，只需要直接删除该结点即可；对于第二种情况，删除后需要让被删除结点的直接后继来接替它的位置；对于第三种情况，需要遍历得到被删除结点的直接前驱或直接后继来接替它的位置，然后再删除</p>
<p>对于二、三种情况图示如下</p>
<p><img src="/../image/tree/17.png" alt="17"></p>
<p><img src="/../image/tree/18.png" alt="18"></p>
<p><img src="/../image/tree/19.png" alt="19"></p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!*T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(key == (*T)-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//找到关键字等于key的数据元素</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Delete</span>(T);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; (*T) -&gt; data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(&amp;(*T) -&gt; lchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(&amp;(*T) -&gt; rchild, key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Delete()</code>函数代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree q, s;</span><br><span class="line">	<span class="keyword">if</span>((*p)-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//右子树为空则只需重接它的左子树</span></span><br><span class="line">		q = *p;</span><br><span class="line">		*p = (*p)-&gt;lchild;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//左子树为空则只需重接它的右子树</span></span><br><span class="line">		q = *p;</span><br><span class="line">		*p = (*p)-&gt;rchild;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//左右子树均不空</span></span><br><span class="line">		q = *p;</span><br><span class="line">		s = (*p)-&gt;lchild;	<span class="comment">//先转左</span></span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">		&#123;<span class="comment">//然后向右到尽头，找待删结点的前驱</span></span><br><span class="line">			q = s;</span><br><span class="line">			s = s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//此时s指向被删结点的直接前驱，p指向s的父母节点</span></span><br><span class="line">		(*p)-&gt;data = s-&gt;data;	<span class="comment">//被删除结点的值替换成它的直接前驱的值</span></span><br><span class="line">		<span class="keyword">if</span>(q != *p)</span><br><span class="line">		&#123;</span><br><span class="line">			q-&gt;rchild = s-&gt;lchild;	<span class="comment">//重接q的右子树</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			q-&gt;lchild = s-&gt;lchild;	<span class="comment">//重接q的左子树</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>二叉排序树的插入和删除的时间性能比较好，对于查找走的就是从根结点到要查找的结点的路径，最少为1次即根结点就是要查找的点，最多不会超过树的深度，即二叉排序树的性能取决于二叉树的形状</p>
<p>对于下图左侧的树，可以称为是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂度为O(logn)，但对于右侧的树，查找的时间复杂度为O(n)，等同于顺序查找。</p>
<img src="../image/tree/20.png" alt="20" style="zoom:50%;" />

<p>所以，如果想要对一个集合按二叉排序树查找，最好将其构造成一棵平衡的二叉排序树</p>
<h2 id="二、平衡二叉树"><a href="#二、平衡二叉树" class="headerlink" title="二、平衡二叉树"></a>二、平衡二叉树</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>平衡二叉树是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1</p>
<p>即要么是一棵空树，要么左子树和右子树都是平衡二叉树，且左子树和右子树深度之差的绝对值不超过1，二叉树上结点的左子树深度减去右子树深度的值称为<strong>平衡因子</strong>，则平衡二叉树上所有结点的平衡因子只可能是1，0，-1</p>
<h3 id="2-平衡二叉树的查找"><a href="#2-平衡二叉树的查找" class="headerlink" title="2.平衡二叉树的查找"></a>2.平衡二叉树的查找</h3><p>平衡二叉树的查找与二叉排序树相同。在平衡二叉树中与给定值进行比较的次数不超过树的深度，假设用n<sub>h</sub>表示深度为h的二叉平衡树中含有的最少结点数，则有n<sub>0</sub>&#x3D;0，n<sub>1</sub>&#x3D;1，n<sub>2</sub>&#x3D;2，并且有n<sub>h</sub>&#x3D;n<sub>h-1</sub>+n<sub>h-2</sub>+1，可以证明含有n个结点的平衡二叉树的最大深度为O(log2n)，因此平衡二叉树的平均查找长度为O(log2n)</p>
<h3 id="3-平衡二叉树的插入"><a href="#3-平衡二叉树的插入" class="headerlink" title="3.平衡二叉树的插入"></a>3.平衡二叉树的插入</h3><p>对于平衡二叉树的插入可能会导致其不平衡，为了保持平衡，有如下方法：</p>
<p>每当在二叉排序树中插入(或删除)一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡，若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点，再对以该结点为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡<br><strong>注意</strong>:每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。下图中的虚线框内为最小不平衡子树</p>
<p><img src="/../image/tree/21.png" alt="21"></p>
<p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：</p>
<p>1.LL平衡旋转（右单旋转）</p>
<p>由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作：将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树</p>
<p>如下图所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度</p>
<p><img src="/../image/tree/22.png" alt="22"></p>
<p>2.RR平衡旋转（左单旋转）</p>
<p>由于在结点A的右孩子(R)的右子树(R)上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作：将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树</p>
<p><img src="/../image/tree/23.png" alt="23"></p>
<p>3.LR平衡旋转（先左后右双旋转）</p>
<p>由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转：先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置（即进行一次RR平衡旋转（左单旋转）），然后再把该C结点向右上旋转提升到A结点的位置（即进行一次LL平衡旋（右单旋转））</p>
<p><img src="/../image/tree/24.png" alt="24"></p>
<p>4.RL平衡旋转（先右后左双旋转）</p>
<p>由于在A的右孩子(R)的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转：先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置（即进行一次LL平衡旋转（右单旋转）），然后再把该C结点向左上旋转提升到A结点的位置（即进行一次RR平衡旋转（左单旋转））</p>
<p><img src="/../image/tree/25.png" alt="25"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">galloprubber</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/16/%E6%A0%91tree/">http://example.com/2025/07/16/%E6%A0%91tree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Welcome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91prim%20Kruskal/" title="最小生成树Prim Kruskal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">最小生成树Prim Kruskal</div></div><div class="info-2"><div class="info-item-1">最小生成树（Minimum Spanning Tree，简称MST）是图论中的一个概念：给定一个连通的无向图，最小生成树是指包含图中所有顶点的一棵树，且该树的所有边权值之和最小 1.朴素Prim1.1基本步骤1.如下图，以结点0为最小生成树的起点，寻找所有点与最小生成树集合的最短距离  2.初始化所有结点与起点0间的距离为一个极大值（表示距离无穷远），并作为这些点与最小生成树的临时距离  3.遍历起点的所有邻接点，更新这些结点与起点的距离（这一步称为松弛操作）  4.在当前所有与最小生成树集合相邻的边中，寻找权重最小的边和它连接的未访问结点，即结点2，将它标记，表示该结点已加入最小生成树集合  5.遍历结点2的所有邻接点，更新这些点与结点2的距离，重复3，4两步，直到所有结点都被标记   最终所有点被标记，加入了最小生成树集合 1.2模版代码使用邻接矩阵存图的模版如下 1.使用数组进行各种记录 123int vis[10005];//记录是否访问过int dis[10005];//存储临时最短距离int M[10005][10005];//存储图  2.初始化所有结点与起点的距离...</div></div></div></a><a class="pagination-related" href="/2025/07/13/%E6%9C%80%E7%9F%AD%E8%B7%AFDijkstra/" title="最短路Dijkstra"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">最短路Dijkstra</div></div><div class="info-2"><div class="info-item-1">Dijkstra算法适用于解决无负权边的单源最短路问题 有负权边的单源最短路——Ford + SPFA(Ford的改进) 多源最短路——Floyd 单源最短路，指图中所有结点到其中一个点的最短距离 1.朴素Dijkstra1.1基本步骤1.如下图，以结点0为起点，寻找所有点距离结点0的最短距离  2.初始化所有结点与起点0间的距离为一个极大值（表示距离无穷远），并作为这些点与起点的临时距离  3.遍历起点的所有邻接点，更新这些结点与起点的距离（这一步称为松弛操作）  4.在当前所有结点与起点的距离中寻找距离最短的点，即结点2，并将它标记，表示找到了该结点与起点0之间的最短距离  5.遍历结点2的所有邻接点，更新这些点通过结点2与起点0连接的距离，重复3，4两步，直到所有结点都被标记   最终所有的结点都被标记，找到了所有结点与起点0的最短距离 步骤以表格形式呈现如下：     第一次 第二次 第三次 第四次 第五次 第六次    1 5 5 已标记 已标记 已标记 已标记   2 2 已标记 已标记 已标记 已标记 已标记   3 ∞ 8 6 已标记 已标记 已标记   4 ∞ ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/21/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="树状数组"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="info-item-2">树状数组</div></div><div class="info-2"><div class="info-item-1">树状数组即一个树型结构的数组，与二叉树类似却又不同 树状数组能解决区间问题：1.单点修改，单点查询 2.区间修改，单点查询 3.区间查询，区间修改 所以线段树能解决的问题，树状数组大部分也能解决，但树状数组比线段树要简单省时 1.基本概念下面是树状数组的结构  创建数组a[i]存储区间内的每一个点，数组t[x]为树状数组  如上图，t[x]保存以x为根的子树中所有叶结点值的和 例如t[4]=t[2]+t[3]+a[4]=t[1]+a[2]+a[3]+a[4]=a[1]+a[2]+a[3]+a[4]  如上图，我们可以发现树状数组中结点x的父结点为x+lowbit(x)，例如t[2]的父结点为t[4] = t[2+lowbit(2)] 2.使用方法1.单点修改，区间查询若要将a[1]+k，则需要对其父结点t[1],[2],[4],t[8]都作更改 1234567int add(int x,int k)&#123;    for(int i=x;i&lt;=n;i+=lowbit(i))    &#123;        t[i] += k;    &#125;&#125;  查询：...</div></div></div></a><a class="pagination-related" href="/2025/10/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-02</div><div class="info-item-2">线性表</div></div><div class="info-2"><div class="info-item-1">1.基本概念由n(n≥0)个数据特性相同的元素构成的有限序列，称为线性表 对于非空的线性表或线性结构，其特点是： (1)存在唯一的一个被称为“第一个”的数据元素 (2)存在唯一的一个被称作“最后一个”的数据元素 (3)除第一个元素以外，结构中的每个数据元素都只有一个前驱 (4)除最后一个元素以外，结构中的每个数据元素都只有一个后继  线性表主要有线性表示及链式表示，这里主要进行链式表示的讨论 2.单链表的定义及表示线性表链式存储的特点是：用一组任意的存储单元存储线性表的数据元素。因此，为了表示每个元素ai与其直接后继ai+1之间的逻辑关系，对数据ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即其直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为结点。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指阵域。指针域中存储的信息称为指针或链。n个结点链接成一个链表，即位线性表的链式存储结构。由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表 单链表的存储结构12345typedef struct LNod...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">galloprubber</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">2.树的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3.树的基本性质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1.双亲表示法（顺序存储）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.孩子表示法（顺序+链式存储）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3.孩子兄弟表示法（链式存储）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">一、二叉树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.二叉树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">二、遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.层次遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text">三、线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.线索二叉树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.线索二叉树的结构实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.二叉树的线索化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">一、二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.二叉排序树的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.</span> <span class="toc-text">二、平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.平衡二叉树的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.平衡二叉树的插入</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表">线性表</a><time datetime="2025-10-02T05:56:00.000Z" title="发表于 2025-10-02 13:56:00">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/27/%E7%BA%BF%E6%80%A7%E5%9F%BA/" title="线性基">线性基</a><time datetime="2025-09-27T06:23:00.000Z" title="发表于 2025-09-27 14:23:00">2025-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/18/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="图的存储方式">图的存储方式</a><time datetime="2025-08-18T01:43:00.000Z" title="发表于 2025-08-18 09:43:00">2025-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/01/%E5%88%86%E6%95%B0%E5%8F%96%E6%A8%A1%EF%BC%88%E6%A8%A1%E9%80%86%E5%85%83%EF%BC%89/" title="分数取模（模逆元）">分数取模（模逆元）</a><time datetime="2025-08-01T08:00:00.000Z" title="发表于 2025-08-01 16:00:00">2025-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="时间复杂度与空间复杂度">时间复杂度与空间复杂度</a><time datetime="2025-07-24T07:25:35.000Z" title="发表于 2025-07-24 15:25:35">2025-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By galloprubber</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>